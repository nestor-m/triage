\section{Pruebas e instalación}
En esta sección describimos todos los tipos de pruebas que realizamos junto con el desarrollo de la aplicación: pruebas unitarias, de integración y funcionales. En segundo lugar mencionamos algunos problemas con los que nos encontramos al incorporar las pruebas al desarrollo. Luego describimos cómo realizamos la instalación del producto final. Y por último mostramos algunas métricas del proyecto.

\subsection{Pruebas}
Desarrollamos la aplicación realizando pruebas unitarias y de integración de cada clase del dominio así como también pruebas funcionales de cada pantalla.

Cada funcionalidad desarrollada tiene su conjunto de pruebas correspondiente. Algunas de las ventajas de usar pruebas automatizadas son las siguientes:

\begin{itemize}
\item Se robustece la aplicación.
\item Se genera confianza en el programador al momento de hacer modificaciones.
\item Se ahorra tiempo.
\item Se disminuye el margen de error en el código.
\end{itemize}

\subsubsection{Pruebas unitarias}
En programación, una prueba unitaria es una forma de comprobar el correcto funcionamiento de un módulo de código. Esto sirve para asegurar que cada uno de los módulos funcione correctamente por separado. Luego, con las Pruebas de Integración, se podrá asegurar el correcto funcionamiento del sistema o subsistema en cuestión. Cabe mencionar que las pruebas unitarias no tienen repercusión en la base de datos. Para realizarlas utilizamos la herramienta nativa de Grails\footnote{\texttt{http://grails.org/doc/latest/guide/testing.html\#unitTesting}} con la biblioteca de Java JUnit\footnote{\texttt{http://junit.org/}}. Así cubrimos el comportamiento de las clases del dominio definidas en el \textit{back-end}

\subsubsection{Pruebas de integración}
Las pruebas de integración son aquellas que se realizan en el ámbito del desarrollo de software una vez que se han aprobado las pruebas unitarias. Se refieren a las pruebas de todos los elementos unitarios que componen un proceso, hechas en conjunto, de una sola vez. Consiste en realizar pruebas para verificar que un gran conjunto de partes de software funciona bien. Las pruebas de integración preceden a las pruebas funcionales del sistema. Cabe mencionar que este tipo de pruebas tiene repercución en la base de datos. Para realizarlas utilizamos la herramienta nativa de Grails\footnote{\texttt{http://grails.org/doc/latest/guide/testing.html\#integrationTesting}}. Con ello cubrimos el comportamiento de los controladores definidos en el \textit{back-end}.

\subsubsection{Pruebas funcionales}
Las pruebas funcionales se basan en la ejecución, revisión y retroalimentación de las funcionalidades previamente diseñadas para el software. Se hacen mediante el diseño de modelos de prueba que buscan evaluar cada una de las opciones con las que cuenta el paquete informático. Dicho de otro modo son pruebas específicas, concretas y exhaustivas para probar y validar que el software hace lo que debe y sobre todo, lo que se ha especificado. Para realizarlas utilizamos CasperJS\footnote{\texttt{http://casperjs.org/}} y Protractor\footnote{\texttt{https://github.com/angular/protractor}} haciendo una simulación del usuario final utilizando la aplicación.

En un primer momento utilizamos CasperJS pero tuvimos muchos problemas para hacerlo funcionar correctamente con AngularJS. Por eso dejamos de usarlo y lo reemplazamos por Protractor.

Para utilizar Protractor necesitamos usar Selenium\footnote{\texttt{http://www.seleniumhq.org/}}, un entorno de pruebas de software para aplicaciones basadas en la web, con un \textit{driver\footnote{\texttt{http://es.wikipedia.org/wiki/Manejador\_de\_dispositivo}}} para el navegador  Chrome\footnote{\texttt{http://www.google.com/intl/es-419/chrome/}}.

\subsubsection{Problemas que tuvimos con el desarrollo de las pruebas}
A continuación detallamos los problemas con los que nos encontramos al utilizar pruebas automatizadas.
\begin{itemize}
\item Hay algunas funciones de Grails que no son soportadas por su ambiente de pruebas. Por eso para que las pruebas pasen, nos vimos obligados a usar solo aquellas funciones que no tenían dicho problema.
\item Tuvimos problemas con Protractor al probar pantallas con ventanas modales. Las ventanas modales son elementos que al aparecer, bloquean la ventana principal de la aplicación. Por eso para poder probar estas pantallas nos vimos obligados a dormir la ejecución de la prueba durante un segundo. Así el modal tenía tiempo para desaparecer y la ventana principal de desbloquearse. Si no hacíamos esto, la prueba fallaba ya que la ejecución de la misma, luego de cerrar el modal, intentaba interactuar con elementos de la ventana principal que aún permanecían bloqueados.
\end{itemize}

\subsection{Instalación}
Acordamos con el Dr. Reggiani hacer la instalación en una máquina del hospital. Como las computadoras están en una misma red entonces la aplicación se encuentra accesible desde cualquier punto del lugar.

La primer instalación (de prueba) la hicimos al promediar el proyecto. El objetivo de la misma fue que los usuarios finales se familiarizacen con el producto, nos dieran \textit{feedback} y propusieran modificaciones de creerlo necesario. La segunda instalación (definitiva) la hicimos al finalizar el proyecto.

Para la instalación de prueba usamos un servidor Tomcat\footnote{\texttt{http://tomcat.apache.org/}} al cual le insertamos el WAR\footnote{\texttt{http://es.wikipedia.org/wiki/WAR\_(archivo)}}(archivo ejecutable que realiza la instalación del producto) de nuestra aplicación que contenía a su vez una base de datos H2\footnote{\texttt{http://www.h2database.com}} embebida.

La instalación final fue similar a la de prueba con la salvedad que no utilizamos la base de datos H2 embebida en Grails. En su lugar instalamos una base de datos PostgreSQL independiente del resto del sistema y, por lo tanto, más segura y confiable.


\subsection{Métricas del proyecto}

\begin{description}
\item[Cantidad de historias de usuario/funcionalidades implementadas] \mbox{} \\
Implementamos 16 funcionalidades.

\item[Cantidad de iteraciones de trabajo] \mbox{} \\
Realizamos el proyecto en 18 iteraciones de una semana de duración cada una. En cada iteración planificamos trabajar 10 horas por desarrollador.

\item[Cantidad de horas trabajadas] \mbox{} \\
Para realizar este proyecto dedicamos un total de 402 horas. Es decir que cada desarrollador trabajó 201 horas.

\item[Cantidad de commits en el repositorio] \mbox{} \\
Realizamos 292 commits en el repositorio de GitHub.

\item[Cantidad de pruebas unitarias] \mbox{} \\
Realizamos 20 pruebas unitarias sobre las clases del dominio Persona y Paciente.

\item[Cantidad de pruebas de integración] \mbox{} \\
Realizamos 26 pruebas de integración sobre los controladores en el \textit{backend} de Persona, Paciente y Síntoma.

\item[Cantidad de pruebas funcionales] \mbox{} \\
Realizamos 66 pruebas funcionales sobre las diferentes pantallas de la aplicación.

\end{description}